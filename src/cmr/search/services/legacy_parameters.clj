(ns cmr.search.services.legacy-parameters
  "Contains functions for tranforming legacy parameters to the CMR format."
  (:require [clojure.set :as set]
            [clojure.walk :as w]))

(def param-aliases
  "A map of non UMM parameter names to their UMM fields."
  {:dataset-id :entry-title
   :dif-entry-id :entry-id
   :campaign :project
   :echo-collection-id :concept-id
   :echo-granule-id :concept-id
   :online-only :downloadable})


(defn- arrange-param-values [params]
  "Collapse multiple items of a value entry into a vector.
  Leave an item as is if value entry is a single item."
  (let [arrange-fn (partial #(if (vector? %)
                               (apply vector (flatten %))
                               %))]
    (reduce #(assoc %1 %2 (arrange-fn (%1 %2))) params (keys params))))

(defn rename-keys-with [m kmap merge-fn]
  "Convert and merge non UMM parameter names to their UMM fields."
  (let [rename-subset (select-keys m (keys kmap))
        renamed-subsets (map (fn [[k v]]
                               (set/rename-keys {k v} kmap))
                             (seq rename-subset))
        merged-renamed-subset (apply merge-with merge-fn renamed-subsets)
        m-without-renamed (apply dissoc m (keys kmap))]
    (arrange-param-values  (merge-with merge-fn m-without-renamed merged-renamed-subset))))

(defn replace-parameter-aliases
  "Walk the request params tree to replace aliases of parameter names."
  [params]
  (let [merge-fn vector]
    (w/postwalk #(if (map? %)
                   (rename-keys-with % param-aliases merge-fn)
                   %)
                params)))

(defn- process-legacy-range-maps
  "Changes legacy map range conditions in the param[minValue]/param[maxValue] format
  to the cmr format: min,max."
  [concept-type params]
  (reduce-kv (fn [memo k v]
               ;; look for parameters in the map form
               (if (map? v)
                 (let [{:keys [value min-value max-value min max]} v]
                   (cond
                     (or min-value max-value)
                     ;; convert the map into a comma separated string
                     (assoc memo k (str min-value "," max-value))

                     (or min max)
                     ;; convert the map into a comma separated string
                     (assoc memo k (str min "," max))

                     value
                     (assoc memo k value)

                     :else ;; do nothing
                     memo))
                 memo))
             params
             params))


(defn- process-equator-crossing-date
  "Legacy format for granule equator crossing date is to specify two separate parameters:
  equator-crossing-start-date and equator-crossing-end-date. This function replaces those
  parameters with the current format of start,end."
  [concept-type params]
  (let [{:keys [equator-crossing-start-date equator-crossing-end-date]} params]
    (if (or equator-crossing-start-date equator-crossing-end-date)
      (-> params
          (dissoc :equator-crossing-start-date :equator-crossing-end-date)
          (assoc :equator-crossing-date (str equator-crossing-start-date
                                             ","
                                             equator-crossing-end-date)))
      params)))

;; Add others to this list as needed - note that order is important here
(def legacy-multi-params-condition-funcs
  "A list of functions to call to transform any legacy parameters into CMR form. Each function
  must accept a pair of arguments [concept-type params] where concept-type is :collection,
  :granule, etc. and params is the parameter map generated by the ring middleware."
  [process-equator-crossing-date
   process-legacy-range-maps])

(defn process-legacy-multi-params-conditions
  "Handle conditions that use a legacy range style of using two parameters to specify a range."
  [concept-type params]
  (reduce #(%2 concept-type %1)
          params
          legacy-multi-params-condition-funcs))


(comment
  ;;;;;;;;;;
  (let [params {:exclude {:concept-id ["G1000000006-CMR_PROV2"],
                          :echo-granule-id ["G1000000006-CMR_PROV2"]
                          :echo-collection-id "C1000000002-CMR_PROV2"},
                :echo-granule-id ["G1000000002-CMR_PROV1" "G1000000003-CMR_PROV1"
                                  "G1000000004-CMR_PROV1" "G1000000005-CMR_PROV2" "G1000000006-CMR_PROV2"]}]
    (replace-parameter-aliases params))


  (rename-keys-with {:foo [1 2] :bar [3 4] :k1 8 :k2 "d"}  {:bar :foo :k1 :foo :k2 :foo} vector)
  ;;;;;;;;;;;;;;;;;
  )



